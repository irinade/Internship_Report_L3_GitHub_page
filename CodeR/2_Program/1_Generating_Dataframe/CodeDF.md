---
title: 'Notebook : Generate Dataframe from Recordings'
author: "Irina Delamare"
date: "13/10/2020"
output: html_document
---

IMPORTANT : To run the code via the bash console, enter the command make main. It will run the program automatically!
You need to make a symlink to the real dir e.g. "(cd; ln -s ~/git/Provini_Internship)" HERE TO REPLACE THIS to make the program work either from Rstudio or from the console. I want Rstdio to home directory to be my computer home directory or the project. It should work because of the symlink Provini_intersnhip in my home directory.

There is some problem with the markdown Rscript, The program works when creating a copy of the markdown in the Rscript, however the markdown does not run properly and return an error.


Installing the right library for the project.

```{r}
#install.packages("soundgen")
#install.packages("tidyverse")
#install.packages("seewave", repos="http://cran.at.r-project.org/")
#install.packages("here")

library(soundgen)
library(ProjectTemplate)
library(tuneR)
library(tidyverse)
library(fs)
library(plyr)
library(dplyr)
library(here)
```

The constant are used to create paths to find the MP3 Audio and to generate the CSV files. 
args is a variable that will take each audio one by one to run the function extract_acoustic on every recordings. It is used to run this program from bash.

```{r}
# constant
#dir <- "~/Provini_Internship/L3_Internship/CodeR/"

dir <- here::here()
audio_dir <- here::here("1_Input", "1_Generating_Dataframe", "Audio")
csv_dir <- here::here("3_Output", "1_Generating_Dataframe", "CSV")

#audio_dir <- paste(dir, "1_Input/1_Generating_Dataframe/Audio", sep = "")
#csv_dir <- paste(dir, "3_Output/1_Generating_Dataframe/CSV/", sep = "")

# variable
args <- commandArgs(trailingOnly=TRUE)
```

Functions to call

```{r}
source(here::here("functions/", "extract_acoustics_from_file.r"))
source(here::here("functions/", "extract_acoustics.r"))
```

Loop that allows running this code from either the terminal or from Rstudio.

```{r}
if (length(args) == 0) { # called from notebook
	# Creating a list containing all the paths of the mp3 files we want to analyze. 
	files <- list.files(path = audio_dir, pattern=(".mp3"))
	for (file in files) {
	  print(file)
		extract_acoustics_from_file(paste(audio_dir, file, sep = "/"), csv_dir)
	}
} else { # called from shell
	extract_acoustics_from_file(args[1], csv_dir)
}
```


Concatenate every CSV files into one CSV dataframe

```{r}

View(Alldf)

csv_files <- list.files(path = csv_dir, pattern = ".csv", full.names = TRUE) # it is important to precise that the pattern we are looking for is .csv format because there are files in CSV folder with .out as format. Those files are generated by the terminal when we run the code via bash and save the error message generated after ridding each sound.

Alldf <- map_df(.x = csv_files, .f = ~read.csv(file = ., header = TRUE)) 
# check with more files and especially the NA. I have the impression that the "unique" function used in the loop may do something different


for (data in csv_files){
  
  file.exists(paste(csv_dir, data, sep=""))
  
  # Create the first data if no data exist yet
  if (!exists("dataset")){
    dataset <- read.csv(data, header=TRUE)
  }
  
  # if data already exist, then append it together
  if (exists("dataset")){
    tempory <-read.csv(data, header=TRUE)
    dataset <-unique(rbind(dataset, tempory))
    rm(tempory)
  }
}
View(dataset)

# !PP! It is working for me: a dataframe with 6 lines, one for each file listed in csv_files

```

see why not working in make main
